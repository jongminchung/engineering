# Sealed Class

Sealed Class(봉인된 클래스)는 Java 17에서 정식 도입된 기능으로, 상속 가능한 하위 클래스를 제한하여 코드의 안전성과 가독성을 높이는 도구입니다.

## 1. 등장 배경: 컴파일러에게 주는 힌트

전통적인 객체지향 프로그래밍에서 상속은 열려 있었습니다. 하지만 라이브러리 설계나 비즈니스 로직 구현 시, "이 클래스는 특정 클래스들만 상속받아야 한다"는 제약이 필요한 경우가 많았습니다.

Sealed Class는 **컴파일러에게 하위 클래스의 전체 목록을 알려줌**으로써 다음과 같은 이점을 제공합니다.

- **Exhaustiveness Check (고갈성 검사)**: switch 문 등에서 모든 하위 타입을 처리했는지 컴파일 타임에 확인할 수 있습니다.
- **제어된 상속**: 무분별한 상속을 방지하여 도메인 모델의 의도를 명확히 합니다.

---

## 2. Sealed Class의 주요 특징

### 선언 방식
`sealed` 키워드와 `permits` 키워드를 사용하여 상속을 허용할 클래스를 명시합니다.

```java
public sealed class Shape permits Circle, Rectangle, Square {
    // ...
}
```

### 하위 클래스의 제약 사항
Sealed 클래스를 상속받는 클래스는 반드시 다음 중 하나의 키워드를 가져야 합니다.

1. `final`: 더 이상 상속 불가.
2. `sealed`: 자신도 하위 클래스를 제한적으로 허용.
3. `non-sealed`: 누구나 상속받을 수 있도록 다시 개방.

---

## 3. 주요 장점

### 패턴 매칭과의 시너지
Java의 최신 기능인 'Pattern Matching for switch'와 결합했을 때 진가를 발휘합니다.

```java
// 모든 permits 클래스를 처리하면 default 케이스가 없어도 컴파일 성공
double area = switch (shape) {
    case Circle c    -> Math.PI * c.radius() * c.radius();
    case Rectangle r -> r.width() * r.height();
    case Square s    -> s.side() * s.side();
};
```

만약 `Shape`에 새로운 하위 클래스가 추가된다면, 컴파일러는 이 switch 문에서 해당 클래스가 누락되었음을 즉시 알려줍니다.

### 도메인 모델링의 명확성
상태를 표현할 때(예: API 응답 상태 Success, Error, Loading) enum보다 풍부한 데이터를 담으면서도(객체 생성 가능), 타입의 종류를 제한할 수 있어 유지보수에 유리합니다.

---

## 4. 요약: 왜 사용하는가?

1. **안정성**: 의도치 않은 상속으로 인한 버그를 방지합니다.
2. **가독성**: 클래스 계층 구조를 한눈에 파악할 수 있습니다.
3. **컴파일러 최적화**: 컴파일러가 타입 계층을 완벽히 이해하여 더 나은 최적화와 검사를 제공합니다.
