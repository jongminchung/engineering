# Java Annotation & Annotation Processor

어노테이션은 원래 코드에 대한 메타데이터를 제공하는 '주석'의 일종으로 시작되었으나, 현대 자바에서는 프레임워크 제어와 컴파일 타임 코드 생성을
위한 핵심 도구로 사용됩니다.

## 1. Annotation의 기본 규약

어노테이션은 코드 자체의 로직에는 직접적인 영향을 주지 않으며, 도구나 라이브러리가 코드를 어떻게 처리할지 알려주는 마크업 역할을 합니다.

### 메타 어노테이션 (Meta-Annotations)

어노테이션을 정의할 때 사용하는 어노테이션입니다.

- **@Target**: 어노테이션이 적용될 위치 (METHOD, FIELD, TYPE 등)를 지정합니다.
- **@Retention**: 어노테이션이 유지되는 범위를 지정합니다.
 	- `SOURCE`: 컴파일 시점에 제거됨 (Lombok 등이 사용)
 	- `CLASS`: 클래스 파일까지 유지되나 런타임에는 참조 불가 (기본값)
 	- `RUNTIME`: 실행 시점에 리플렉션을 통해 참조 가능 (Spring DI 등이 사용)

---

## 2. 코드 생성과 Annotation Processor

어노테이션의 본래 규약은 '데이터에 대한 데이터'일 뿐이지만, **Annotation Processor**를 사용하면 컴파일 타임에 코드를
분석하고 새로운 파일을 생성할 수 있습니다.

### Lombok의 마법

Lombok은 일반적인 어노테이션 프로세서와는 조금 다른 방식으로 동작합니다.

1. **표준 방식**: 보통의 프로세서는 새로운 자바 파일(.java)을 생성만 할 수 있고 기존 코드를 수정할 수는 없습니다.
2. **Lombok 방식**: 컴파일러 내부의 AST(Abstract Syntax Tree, 추상 구문 트리)를 직접 수정합니다.
	- `@Getter`가 붙은 필드를 보고 컴파일러 단계에서 바이트코드에 getter 메서드를 주입합니다.
	- 이 때문에 소스 코드에는 없지만 컴파일된 클래스 파일에는 메서드가 존재하는 '코드 생성'이 이루어집니다.

### 주요 코드 생성 라이브러리

- **Lombok**: `@Data`, `@Builder` 등을 통해 반복적인 보일러플레이트 코드(Getter/Setter, 생성자 등) 자동
	생성.
- **MapStruct**: 객체 간 매핑 로직(DTO <-> Entity)을 어노테이션 기반으로 컴파일 타임에 생성하여 성능과 안정성 확보.
- **QueryDSL**: 엔티티 클래스를 분석하여 타입 세이프한 쿼리를 작성할 수 있는 Q-Class 생성.

---

## 3. 요약: 주석인가, 코드인가?

- **과거**: "이 메서드는 상위 클래스를 오버라이드함(@Override)"과 같은 정보 전달용 주석.
- **현재**:
 	- **Runtime**: 리플렉션을 통해 프레임워크(Spring)가 객체를 관리하는 설정 정보.
 	- **Compile-time**: 반복되는 코드를 대신 작성해 주는 자동화 도구 (Lombok, MapStruct).

현대 자바 개발에서 어노테이션은 단순한 주석을 넘어, **선언적 프로그래밍**을 가능하게 하는 강력한 메타 프로그래밍 수단입니다.
