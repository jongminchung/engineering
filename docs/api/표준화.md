# API 표준화

## 시작 단계

- LB (or Gateway API, TLS Termination. 외부 HTTP/2)
- 내부: HTTP/1.1 + 표준 커넥션 풀(TTL/eviction) + 제한적 retry + CB
- 장기 로드맵: mesh 도입(mTLS + 관측)

## 중간 단계

- 내부: gRPC(HTTP/2) 표준화 (HTTP)
- Service Mesh로 mTLS + 트래픽 정책(리트라이/타임아웃/서킷브레이커) 중앙관리
- 앱 코드는 단순화

## 메서드

RFC 9110 (HTTP Semantics)

> PUT 메서드에서 자원을 생성했다면 반드시 201을 써라!

- **서버 상태의 "최종 결과"가 같으면 멱등**
- “처리했는지 / 안 했는지”는 중요하지 않음
- 리소스 존재 여부와는 무관

👉 즉, “있으면 지우고, 없으면 아무 일도 안 일어남” 은 완벽한 멱등 처리

- GET, PUT, DELETE (멱등)
  - 자원이 존재하면 동일하게 서버가 처리한다는 의미다.
- POST (`Idempotency-Key` 필수)
  - 네트워크 불확실성 속에서 같은 요청을 다시 보내도 서버가 한 번만 처리하도록 만드는 장치(특히 POST)

## 데이터 제어

> Idempotency-Key는 요청 단위 중복 제거(dedup) 용이고,
> 낙관적 락/ETag는 리소스 버전 충돌 방지(concurrency) 용이다.
> 서로 대체되지 않는다.
>
> - Idempotency-Key는 ‘의도를 최초로 만든 주체’가 생성한다.

### 내부 낙관적 락

DB 레벨: `updated_at`

즉, “데이터 무결성”은 외부 계약에 맡기면 안 되고 내부에서 강제해야 한다.

분산락.. (Redis): 모든 MS에 연결되는 락 관리 컴포넌트


### ETag

역할을 낙관적 락으로도 사용할 수 있지만

- GET 캐시 최적화

